package wrapper

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// ZshWrapper implements WrapperGenerator for Zsh shell
type ZshWrapper struct {
	shell SupportedShell
}

// GenerateFunction returns the Zsh-compatible wrapper function content
func (z *ZshWrapper) GenerateFunction() string {
	core := NewWrapperCore()
	function, err := core.GenerateShellWrapperFunction(z.shell)
	if err != nil {
		// Fallback to basic implementation if core generation fails
		return z.generateFallbackFunction()
	}
	return function
}

// generateFallbackFunction provides a fallback implementation
func (z *ZshWrapper) generateFallbackFunction() string {
	return `#compdef aws
# AWS CLI wrapper function with automatic credential refresh
# Generated by awsm wrapper command

aws() {
    # Check if credentials are valid by calling aws sts get-caller-identity
    if ! command aws sts get-caller-identity >/dev/null 2>&1; then
        echo "AWS credentials expired or invalid. Refreshing..." >&2
        
        # Attempt to refresh credentials using awsm
        if ! awsm refresh; then
            echo "Failed to refresh AWS credentials. Please check your awsm configuration." >&2
            return 1
        fi
        
        echo "Credentials refreshed successfully." >&2
    fi
    
    # Execute the original AWS CLI command with all arguments
    command aws "$@"
}
`
}

// GetInstallPath returns the path where the Zsh wrapper function should be installed
func (z *ZshWrapper) GetInstallPath() (string, error) {
	return GetShellInstallPath(z.shell)
}

// GetConfigFile returns the path to the Zsh configuration file
func (z *ZshWrapper) GetConfigFile() (string, error) {
	paths, err := GetShellConfigPaths(z.shell)
	if err != nil {
		return "", err
	}

	// Check for existing config file
	if existing := FindExistingConfigFile(paths); existing != "" {
		return existing, nil
	}

	// Return default path if none exist
	return GetDefaultConfigFile(z.shell)
}

// Install installs the Zsh wrapper function
func (z *ZshWrapper) Install(functionContent string) error {
	// Get installation path for the function file
	installPath, err := z.GetInstallPath()
	if err != nil {
		return NewWrapperError(string(z.shell), "install", err, "failed to get install path")
	}

	// Ensure the functions directory exists with proper validation
	functionsDir := filepath.Dir(installPath)
	if err := z.ensureFunctionsDirectory(functionsDir); err != nil {
		return err // Already wrapped with proper error context
	}

	// Check if already installed
	if FileExists(installPath) {
		return NewWrapperError(string(z.shell), "install", ErrAlreadyInstalled, "wrapper function already exists")
	}

	// Write the function file with validation
	if err := z.writeWrapperFunction(installPath, functionContent); err != nil {
		return err // Already wrapped with proper error context
	}

	// Update .zshrc to add functions directory to fpath
	if err := z.updateZshrcWithValidation(); err != nil {
		// Clean up function file if zshrc update fails
		if removeErr := os.Remove(installPath); removeErr != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed to clean up function file after zshrc update failure: %v\n", removeErr)
		}
		return err // Already wrapped with proper error context
	}

	return nil
}

// ensureFunctionsDirectory creates the Zsh functions directory with validation
func (z *ZshWrapper) ensureFunctionsDirectory(functionsDir string) error {
	if err := EnsureDir(functionsDir); err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(z.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied creating functions directory: %s", functionsDir))
		}
		return NewWrapperError(string(z.shell), "install", err,
			fmt.Sprintf("failed to create functions directory: %s", functionsDir))
	}

	// Test write permissions in the functions directory
	testFile := filepath.Join(functionsDir, ".awsm-write-test")
	if file, err := os.Create(testFile); err != nil {
		return NewWrapperError(string(z.shell), "install", ErrDirectoryNotWritable,
			fmt.Sprintf("functions directory is not writable: %s", functionsDir))
	} else {
		file.Close()
		os.Remove(testFile)
	}

	return nil
}

// writeWrapperFunction writes the wrapper function with validation
func (z *ZshWrapper) writeWrapperFunction(installPath, functionContent string) error {
	if err := os.WriteFile(installPath, []byte(functionContent), 0644); err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(z.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied writing function file: %s", installPath))
		}
		return NewWrapperError(string(z.shell), "install", err,
			fmt.Sprintf("failed to write function file: %s", installPath))
	}
	return nil
}

// updateZshrcWithValidation updates .zshrc with enhanced error handling
func (z *ZshWrapper) updateZshrcWithValidation() error {
	configFile, err := z.GetConfigFile()
	if err != nil {
		return NewWrapperError(string(z.shell), "install", err, "failed to get .zshrc path")
	}

	// Get the functions directory
	functionsDir, err := GetShellFunctionDirectory(z.shell)
	if err != nil {
		return NewWrapperError(string(z.shell), "install", err, "failed to get functions directory")
	}

	// Check if fpath entry already exists
	if z.fpathEntryExists(configFile, functionsDir) {
		return nil // Already configured
	}

	// Validate config file accessibility
	if err := z.validateConfigFileAccess(configFile); err != nil {
		return err // Already wrapped with proper error context
	}

	// Backup existing config file
	if FileExists(configFile) {
		if err := BackupFile(configFile); err != nil {
			return NewWrapperError(string(z.shell), "install", ErrBackupFailed,
				fmt.Sprintf("failed to backup .zshrc: %s", configFile))
		}
	}

	// Add fpath entry to .zshrc
	fpathEntry := fmt.Sprintf("\n# Added by awsm wrapper command\nfpath=(%s $fpath)\nautoload -Uz aws\n", functionsDir)

	if err := z.appendToConfigFile(configFile, fpathEntry); err != nil {
		return err // Already wrapped with proper error context
	}

	return nil
}

// validateConfigFileAccess validates that the config file can be created or modified
func (z *ZshWrapper) validateConfigFileAccess(configFile string) error {
	// Create config file if it doesn't exist
	if !FileExists(configFile) {
		configDir := filepath.Dir(configFile)
		if err := EnsureDir(configDir); err != nil {
			if os.IsPermission(err) {
				return NewWrapperError(string(z.shell), "install", ErrPermissionDenied,
					fmt.Sprintf("permission denied creating config directory: %s", configDir))
			}
			return NewWrapperError(string(z.shell), "install", err,
				fmt.Sprintf("failed to create config directory: %s", configDir))
		}

		// Test if we can create the config file
		if file, err := os.Create(configFile); err != nil {
			if os.IsPermission(err) {
				return NewWrapperError(string(z.shell), "install", ErrPermissionDenied,
					fmt.Sprintf("permission denied creating .zshrc: %s", configFile))
			}
			return NewWrapperError(string(z.shell), "install", err,
				fmt.Sprintf("failed to create .zshrc: %s", configFile))
		} else {
			file.Close()
		}
	} else {
		// Test if existing file is writable
		if file, err := os.OpenFile(configFile, os.O_WRONLY|os.O_APPEND, 0644); err != nil {
			if os.IsPermission(err) {
				return NewWrapperError(string(z.shell), "install", ErrConfigFileNotWritable,
					fmt.Sprintf(".zshrc is not writable: %s", configFile))
			}
			return NewWrapperError(string(z.shell), "install", err,
				fmt.Sprintf("failed to open .zshrc for writing: %s", configFile))
		} else {
			file.Close()
		}
	}

	return nil
}

// appendToConfigFile appends content to the config file with error handling
func (z *ZshWrapper) appendToConfigFile(configFile, content string) error {
	file, err := os.OpenFile(configFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(z.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied opening .zshrc: %s", configFile))
		}
		return NewWrapperError(string(z.shell), "install", err,
			fmt.Sprintf("failed to open .zshrc: %s", configFile))
	}
	defer file.Close()

	if _, err := file.WriteString(content); err != nil {
		return NewWrapperError(string(z.shell), "install", err,
			fmt.Sprintf("failed to write to .zshrc: %s", configFile))
	}

	return nil
}

// Uninstall removes the Zsh wrapper function
func (z *ZshWrapper) Uninstall() error {
	installPath, err := z.GetInstallPath()
	if err != nil {
		return NewWrapperError(string(z.shell), "uninstall", err, "failed to get install path")
	}

	// Check if installed
	if !FileExists(installPath) {
		return NewWrapperError(string(z.shell), "uninstall", ErrNotInstalled, "wrapper function not found")
	}

	// Remove the function file
	if err := os.Remove(installPath); err != nil {
		return NewWrapperError(string(z.shell), "uninstall", err, "failed to remove function file")
	}

	// Note: We don't remove the fpath entry from .zshrc as it might be used by other functions
	// and removing it could break other functionality

	return nil
}

// IsInstalled checks if the Zsh wrapper function is currently installed
func (z *ZshWrapper) IsInstalled() (bool, error) {
	installPath, err := z.GetInstallPath()
	if err != nil {
		return false, NewWrapperError(string(z.shell), "status", err, "failed to get install path")
	}

	return FileExists(installPath), nil
}

// updateZshrc adds the functions directory to fpath in .zshrc if not already present
func (z *ZshWrapper) updateZshrc() error {
	configFile, err := z.GetConfigFile()
	if err != nil {
		return fmt.Errorf("failed to get config file: %w", err)
	}

	// Get the functions directory
	functionsDir, err := GetShellFunctionDirectory(z.shell)
	if err != nil {
		return fmt.Errorf("failed to get functions directory: %w", err)
	}

	// Check if fpath entry already exists
	if z.fpathEntryExists(configFile, functionsDir) {
		return nil // Already configured
	}

	// Create config file if it doesn't exist
	if !FileExists(configFile) {
		if err := EnsureDir(filepath.Dir(configFile)); err != nil {
			return fmt.Errorf("failed to create config directory: %w", err)
		}
	}

	// Backup existing config file
	if FileExists(configFile) {
		if err := BackupFile(configFile); err != nil {
			return fmt.Errorf("failed to backup config file: %w", err)
		}
	}

	// Add fpath entry to .zshrc
	fpathEntry := fmt.Sprintf("\n# Added by awsm wrapper command\nfpath=(%s $fpath)\nautoload -Uz aws\n", functionsDir)

	file, err := os.OpenFile(configFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		return fmt.Errorf("failed to open config file: %w", err)
	}
	defer file.Close()

	if _, err := file.WriteString(fpathEntry); err != nil {
		return fmt.Errorf("failed to write to config file: %w", err)
	}

	return nil
}

// fpathEntryExists checks if the functions directory is already in fpath in the config file
func (z *ZshWrapper) fpathEntryExists(configFile, functionsDir string) bool {
	if !FileExists(configFile) {
		return false
	}

	file, err := os.Open(configFile)
	if err != nil {
		return false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Check for fpath entries that include our functions directory
		if strings.Contains(line, "fpath=") && strings.Contains(line, functionsDir) {
			return true
		}

		// Also check for autoload entries for aws function
		if strings.Contains(line, "autoload") && strings.Contains(line, "aws") {
			return true
		}
	}

	return false
}
