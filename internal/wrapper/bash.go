package wrapper

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// BashWrapper implements WrapperGenerator for Bash shell
type BashWrapper struct {
	shell SupportedShell
}

// GenerateFunction returns the Bash-compatible wrapper function content
func (b *BashWrapper) GenerateFunction() string {
	core := NewWrapperCore()
	function, err := core.GenerateShellWrapperFunction(b.shell)
	if err != nil {
		// Fallback to basic implementation if core generation fails
		return b.generateFallbackFunction()
	}
	return function
}

// generateFallbackFunction provides a fallback implementation
func (b *BashWrapper) generateFallbackFunction() string {
	return `# AWS CLI wrapper function with automatic credential refresh
# Generated by awsm wrapper command

aws() {
    # Check if credentials are valid by calling aws sts get-caller-identity
    if ! command aws sts get-caller-identity >/dev/null 2>&1; then
        echo "AWS credentials expired or invalid. Refreshing..." >&2
        
        # Attempt to refresh credentials using awsm
        if ! awsm refresh; then
            echo "Failed to refresh AWS credentials. Please check your awsm configuration." >&2
            return 1
        fi
        
        echo "Credentials refreshed successfully." >&2
    fi
    
    # Execute the original AWS CLI command with all arguments
    command aws "$@"
}
`
}

// GetInstallPath returns the path where the Bash wrapper function should be installed
// For Bash, the function is installed directly in the config file, not a separate file
func (b *BashWrapper) GetInstallPath() (string, error) {
	return GetShellInstallPath(b.shell)
}

// GetConfigFile returns the path to the Bash configuration file
func (b *BashWrapper) GetConfigFile() (string, error) {
	paths, err := GetShellConfigPaths(b.shell)
	if err != nil {
		return "", err
	}

	// Check for existing config file
	if existing := FindExistingConfigFile(paths); existing != "" {
		return existing, nil
	}

	// Return default path if none exist
	return GetDefaultConfigFile(b.shell)
}

// Install installs the Bash wrapper function by appending it to ~/.bashrc
func (b *BashWrapper) Install(functionContent string) error {
	configFile, err := b.GetConfigFile()
	if err != nil {
		return NewWrapperError(string(b.shell), "install", err, "failed to get config file")
	}

	// Check if already installed
	installed, err := b.IsInstalled()
	if err != nil {
		return NewWrapperError(string(b.shell), "install", err, "failed to check installation status")
	}
	if installed {
		return NewWrapperError(string(b.shell), "install", ErrAlreadyInstalled, "wrapper function already exists")
	}

	// Validate config file accessibility
	if err := b.validateConfigFileAccess(configFile); err != nil {
		return err // Already wrapped with proper error context
	}

	// Backup existing config file if it exists
	if FileExists(configFile) {
		if err := BackupFile(configFile); err != nil {
			return NewWrapperError(string(b.shell), "install", ErrBackupFailed,
				fmt.Sprintf("failed to backup .bashrc: %s", configFile))
		}
	}

	// Append the wrapper function to the config file
	if err := b.appendToConfigFileWithValidation(configFile, functionContent); err != nil {
		return err // Already wrapped with proper error context
	}

	return nil
}

// validateConfigFileAccess validates that the config file can be created or modified
func (b *BashWrapper) validateConfigFileAccess(configFile string) error {
	// Ensure the config directory exists
	configDir := filepath.Dir(configFile)
	if err := EnsureDir(configDir); err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(b.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied creating config directory: %s", configDir))
		}
		return NewWrapperError(string(b.shell), "install", err,
			fmt.Sprintf("failed to create config directory: %s", configDir))
	}

	// Create config file if it doesn't exist
	if !FileExists(configFile) {
		if file, err := os.Create(configFile); err != nil {
			if os.IsPermission(err) {
				return NewWrapperError(string(b.shell), "install", ErrPermissionDenied,
					fmt.Sprintf("permission denied creating .bashrc: %s", configFile))
			}
			return NewWrapperError(string(b.shell), "install", err,
				fmt.Sprintf("failed to create .bashrc: %s", configFile))
		} else {
			file.Close()
		}
	} else {
		// Test if existing file is writable
		if file, err := os.OpenFile(configFile, os.O_WRONLY|os.O_APPEND, 0644); err != nil {
			if os.IsPermission(err) {
				return NewWrapperError(string(b.shell), "install", ErrConfigFileNotWritable,
					fmt.Sprintf(".bashrc is not writable: %s", configFile))
			}
			return NewWrapperError(string(b.shell), "install", err,
				fmt.Sprintf("failed to open .bashrc for writing: %s", configFile))
		} else {
			file.Close()
		}
	}

	return nil
}

// appendToConfigFileWithValidation appends the wrapper function with enhanced error handling
func (b *BashWrapper) appendToConfigFileWithValidation(configFile, functionContent string) error {
	// Add a comment header and the function content
	content := fmt.Sprintf("\n# Added by awsm wrapper command\n%s", functionContent)

	file, err := os.OpenFile(configFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(b.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied opening .bashrc: %s", configFile))
		}
		return NewWrapperError(string(b.shell), "install", err,
			fmt.Sprintf("failed to open .bashrc: %s", configFile))
	}
	defer file.Close()

	if _, err := file.WriteString(content); err != nil {
		return NewWrapperError(string(b.shell), "install", err,
			fmt.Sprintf("failed to write to .bashrc: %s", configFile))
	}

	return nil
}

// Uninstall removes the Bash wrapper function from ~/.bashrc
func (b *BashWrapper) Uninstall() error {
	configFile, err := b.GetConfigFile()
	if err != nil {
		return NewWrapperError(string(b.shell), "uninstall", err, "failed to get config file")
	}

	// Check if installed
	installed, err := b.IsInstalled()
	if err != nil {
		return NewWrapperError(string(b.shell), "uninstall", err, "failed to check installation status")
	}
	if !installed {
		return NewWrapperError(string(b.shell), "uninstall", ErrNotInstalled, "wrapper function not found")
	}

	// Backup existing config file
	if err := BackupFile(configFile); err != nil {
		return NewWrapperError(string(b.shell), "uninstall", err, "failed to backup config file")
	}

	// Remove the wrapper function from the config file
	if err := b.removeFromConfigFile(configFile); err != nil {
		return NewWrapperError(string(b.shell), "uninstall", err, "failed to remove function from config file")
	}

	return nil
}

// IsInstalled checks if the Bash wrapper function is currently installed
func (b *BashWrapper) IsInstalled() (bool, error) {
	configFile, err := b.GetConfigFile()
	if err != nil {
		return false, NewWrapperError(string(b.shell), "status", err, "failed to get config file")
	}

	if !FileExists(configFile) {
		return false, nil
	}

	return b.functionExistsInFile(configFile), nil
}

// appendToConfigFile appends the wrapper function to the Bash configuration file
func (b *BashWrapper) appendToConfigFile(configFile, functionContent string) error {
	// Add a comment header and the function content
	content := fmt.Sprintf("\n# Added by awsm wrapper command\n%s", functionContent)

	file, err := os.OpenFile(configFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		return fmt.Errorf("failed to open config file: %w", err)
	}
	defer file.Close()

	if _, err := file.WriteString(content); err != nil {
		return fmt.Errorf("failed to write to config file: %w", err)
	}

	return nil
}

// removeFromConfigFile removes the wrapper function from the Bash configuration file
func (b *BashWrapper) removeFromConfigFile(configFile string) error {
	// Read the entire file
	content, err := os.ReadFile(configFile)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	lines := strings.Split(string(content), "\n")
	var newLines []string
	inWrapperSection := false
	inWrapperFunction := false

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)

		// Check if we're entering the wrapper section
		if strings.Contains(line, "Added by awsm wrapper command") {
			inWrapperSection = true
			continue // Skip the comment line
		}

		// Check if we're entering the aws function
		if inWrapperSection && (strings.HasPrefix(trimmedLine, "aws()") || strings.HasPrefix(trimmedLine, "aws ()")) {
			inWrapperFunction = true
			continue // Skip the function declaration
		}

		// Check if we're exiting the function (closing brace at start of line)
		if inWrapperFunction && trimmedLine == "}" {
			inWrapperFunction = false
			inWrapperSection = false
			continue // Skip the closing brace
		}

		// Skip lines that are part of the wrapper function
		if inWrapperFunction {
			continue
		}

		// Keep all other lines
		newLines = append(newLines, line)
	}

	// Write the modified content back to the file
	newContent := strings.Join(newLines, "\n")
	if err := os.WriteFile(configFile, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("failed to write modified config file: %w", err)
	}

	return nil
}

// functionExistsInFile checks if the aws wrapper function exists in the given file
func (b *BashWrapper) functionExistsInFile(configFile string) bool {
	file, err := os.Open(configFile)
	if err != nil {
		return false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	foundComment := false

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Look for the awsm wrapper comment
		if strings.Contains(line, "Added by awsm wrapper command") {
			foundComment = true
			continue
		}

		// Look for the aws function declaration after finding the comment
		if foundComment && (strings.HasPrefix(line, "aws()") || strings.HasPrefix(line, "aws ()")) {
			return true
		}

		// Reset if we find a non-comment, non-aws function line that indicates we've moved past our section
		if foundComment && !strings.HasPrefix(line, "#") && line != "" && !strings.HasPrefix(line, "aws()") && !strings.HasPrefix(line, "aws ()") {
			// If we find a non-comment line that's not the aws function, keep looking
			// This allows for multiple comment lines between the marker and the function
			continue
		}
	}

	return false
}
