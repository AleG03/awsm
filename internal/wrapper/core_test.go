package wrapper

import (
	"strings"
	"testing"
	"time"
)

func TestNewWrapperCore(t *testing.T) {
	core := NewWrapperCore()

	if core.CredentialCheckTimeout != 10*time.Second {
		t.Errorf("Expected CredentialCheckTimeout to be 10s, got %v", core.CredentialCheckTimeout)
	}

	if core.RefreshTimeout != 30*time.Second {
		t.Errorf("Expected RefreshTimeout to be 30s, got %v", core.RefreshTimeout)
	}

	if !core.SuppressOutput {
		t.Error("Expected SuppressOutput to be true")
	}
}

func TestCheckCredentials(t *testing.T) {
	core := NewWrapperCore()

	// Test with a very short timeout to ensure it fails quickly
	core.CredentialCheckTimeout = 1 * time.Millisecond

	// This should fail due to timeout (unless aws is not installed, which is also fine)
	result := core.CheckCredentials()

	// We can't guarantee the result since it depends on system state,
	// but we can verify the function doesn't panic and returns a boolean
	if result != true && result != false {
		t.Error("CheckCredentials should return a boolean value")
	}
}

func TestRefreshCredentials(t *testing.T) {
	core := NewWrapperCore()

	// Test with a very short timeout to ensure it fails quickly
	core.RefreshTimeout = 1 * time.Millisecond

	err := core.RefreshCredentials()

	// This should fail due to timeout or command not found
	if err == nil {
		t.Error("Expected RefreshCredentials to fail with short timeout")
	}

	// Check that timeout errors are properly handled
	if strings.Contains(err.Error(), "timed out") {
		// This is expected with the short timeout
		return
	}

	// Check for command not found or other execution errors
	if !strings.Contains(err.Error(), "failed to refresh credentials") {
		t.Errorf("Expected error message to contain 'failed to refresh credentials', got: %v", err)
	}
}

func TestExecuteAWSCommand(t *testing.T) {
	core := NewWrapperCore()

	// Test with a command that should fail (invalid AWS command)
	exitCode := core.ExecuteAWSCommand([]string{"invalid-command-that-does-not-exist"})

	// Should return non-zero exit code for invalid command
	if exitCode == 0 {
		t.Error("Expected non-zero exit code for invalid AWS command")
	}
}

func TestGenerateShellWrapperFunction(t *testing.T) {
	core := NewWrapperCore()

	testCases := []struct {
		shell    SupportedShell
		expected string
	}{
		{ShellZsh, "#compdef aws"},
		{ShellBash, "# AWS CLI wrapper function"},
		{ShellFish, "function aws --description"},
		{ShellPowerShell, "function aws {"},
	}

	for _, tc := range testCases {
		t.Run(string(tc.shell), func(t *testing.T) {
			result, err := core.GenerateShellWrapperFunction(tc.shell)
			if err != nil {
				t.Fatalf("Unexpected error for shell %s: %v", tc.shell, err)
			}

			if !strings.Contains(result, tc.expected) {
				t.Errorf("Expected wrapper for %s to contain '%s', got: %s", tc.shell, tc.expected, result)
			}

			// Verify all wrappers contain the core logic elements
			expectedElements := []string{
				"AWS CLI wrapper function",
				"Generated by awsm wrapper command",
				"aws sts get-caller-identity",
				"awsm refresh",
				"command aws", // or equivalent for PowerShell
			}

			for _, element := range expectedElements {
				if !strings.Contains(result, element) && !strings.Contains(result, "Get-Command aws") {
					t.Errorf("Expected wrapper for %s to contain '%s'", tc.shell, element)
				}
			}
		})
	}
}

func TestGenerateShellWrapperFunctionUnsupported(t *testing.T) {
	core := NewWrapperCore()

	_, err := core.GenerateShellWrapperFunction("unsupported-shell")
	if err == nil {
		t.Error("Expected error for unsupported shell")
	}

	if !strings.Contains(err.Error(), "unsupported shell") {
		t.Errorf("Expected error message to contain 'unsupported shell', got: %v", err)
	}
}

func TestWrapperLogicIntegration(t *testing.T) {
	// This is an integration test that requires careful setup
	// We'll test the logic flow without actually executing AWS commands

	core := NewWrapperCore()

	// Note: In a real test environment, we would mock the external commands
	// For now, we test the integration as-is

	// Test that the function handles the flow correctly
	// In a real test environment, we would mock the external commands
	args := []string{"s3", "ls"}
	exitCode := core.WrapperLogic(args)

	// The exit code will depend on system state, but should be valid
	if exitCode < 0 || exitCode > 255 {
		t.Errorf("Invalid exit code: %d", exitCode)
	}
}

// TestShellSpecificWrapperGeneration tests that each shell generates valid syntax
func TestShellSpecificWrapperGeneration(t *testing.T) {
	core := NewWrapperCore()

	t.Run("Zsh", func(t *testing.T) {
		result := core.generateZshWrapper()

		// Check for Zsh-specific syntax
		if !strings.Contains(result, "#compdef aws") {
			t.Error("Zsh wrapper should contain completion directive")
		}
		if !strings.Contains(result, `command aws "$@"`) {
			t.Error("Zsh wrapper should use proper argument expansion")
		}
		if !strings.Contains(result, ">&2") {
			t.Error("Zsh wrapper should redirect messages to stderr")
		}
	})

	t.Run("Bash", func(t *testing.T) {
		result := core.generateBashWrapper()

		// Check for Bash-specific syntax
		if !strings.Contains(result, `command aws "$@"`) {
			t.Error("Bash wrapper should use proper argument expansion")
		}
		if !strings.Contains(result, ">&2") {
			t.Error("Bash wrapper should redirect messages to stderr")
		}
	})

	t.Run("Fish", func(t *testing.T) {
		result := core.generateFishWrapper()

		// Check for Fish-specific syntax
		if !strings.Contains(result, "function aws --description") {
			t.Error("Fish wrapper should use function declaration with description")
		}
		if !strings.Contains(result, "command aws $argv") {
			t.Error("Fish wrapper should use $argv for arguments")
		}
		if !strings.Contains(result, "end") {
			t.Error("Fish wrapper should use 'end' to close blocks")
		}
		if !strings.Contains(result, ">&2") {
			t.Error("Fish wrapper should redirect messages to stderr")
		}
	})

	t.Run("PowerShell", func(t *testing.T) {
		result := core.generatePowerShellWrapper()

		// Check for PowerShell-specific syntax
		if !strings.Contains(result, "function aws {") {
			t.Error("PowerShell wrapper should use function declaration")
		}
		if !strings.Contains(result, "Get-Command aws -CommandType Application") {
			t.Error("PowerShell wrapper should use Get-Command to find original aws")
		}
		if !strings.Contains(result, "@args") {
			t.Error("PowerShell wrapper should use @args for arguments")
		}
		if !strings.Contains(result, "Start-Job") {
			t.Error("PowerShell wrapper should use Start-Job for timeout handling")
		}
	})
}

// TestPerformanceOptimizations tests that the wrapper minimizes overhead
func TestPerformanceOptimizations(t *testing.T) {
	core := NewWrapperCore()

	// Test that credential check timeout is reasonable
	if core.CredentialCheckTimeout > 15*time.Second {
		t.Error("Credential check timeout should be reasonable (<=15s) for performance")
	}

	// Test that output is suppressed by default for performance
	if !core.SuppressOutput {
		t.Error("Output should be suppressed by default for better performance")
	}

	// Test that the generated functions use 'command' prefix to avoid recursion
	shells := []SupportedShell{ShellZsh, ShellBash, ShellFish}
	for _, shell := range shells {
		wrapper, err := core.GenerateShellWrapperFunction(shell)
		if err != nil {
			t.Fatalf("Failed to generate wrapper for %s: %v", shell, err)
		}

		if !strings.Contains(wrapper, "command aws") {
			t.Errorf("Wrapper for %s should use 'command aws' to avoid recursion", shell)
		}
	}

	// PowerShell uses a different approach
	psWrapper, err := core.GenerateShellWrapperFunction(ShellPowerShell)
	if err != nil {
		t.Fatalf("Failed to generate PowerShell wrapper: %v", err)
	}

	if !strings.Contains(psWrapper, "Get-Command aws -CommandType Application") {
		t.Error("PowerShell wrapper should use Get-Command to avoid recursion")
	}
}

// TestErrorHandling tests comprehensive error handling
func TestErrorHandling(t *testing.T) {
	core := NewWrapperCore()

	// Test timeout handling in credential check
	core.CredentialCheckTimeout = 1 * time.Nanosecond
	result := core.CheckCredentials()
	// Should handle timeout gracefully and return false
	if result {
		t.Error("Expected CheckCredentials to return false with extremely short timeout")
	}

	// Test timeout handling in refresh
	core.RefreshTimeout = 1 * time.Nanosecond
	err := core.RefreshCredentials()
	if err == nil {
		t.Error("Expected RefreshCredentials to fail with extremely short timeout")
	}

	if !strings.Contains(err.Error(), "timed out") {
		t.Errorf("Expected timeout error message, got: %v", err)
	}
}

// BenchmarkCredentialCheck benchmarks the credential checking performance
func BenchmarkCredentialCheck(b *testing.B) {
	core := NewWrapperCore()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		core.CheckCredentials()
	}
}

// BenchmarkWrapperGeneration benchmarks wrapper function generation
func BenchmarkWrapperGeneration(b *testing.B) {
	core := NewWrapperCore()

	shells := []SupportedShell{ShellZsh, ShellBash, ShellFish, ShellPowerShell}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		for _, shell := range shells {
			_, err := core.GenerateShellWrapperFunction(shell)
			if err != nil {
				b.Fatalf("Failed to generate wrapper for %s: %v", shell, err)
			}
		}
	}
}
