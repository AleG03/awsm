package wrapper

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// PowerShellWrapper implements WrapperGenerator for PowerShell
type PowerShellWrapper struct {
	shell SupportedShell
}

// GenerateFunction returns the PowerShell-compatible wrapper function content
func (p *PowerShellWrapper) GenerateFunction() string {
	core := NewWrapperCore()
	function, err := core.GenerateShellWrapperFunction(p.shell)
	if err != nil {
		// Fallback to basic implementation if core generation fails
		return p.generateFallbackFunction()
	}
	return function
}

// generateFallbackFunction provides a fallback implementation
func (p *PowerShellWrapper) generateFallbackFunction() string {
	return `# AWS CLI wrapper function with automatic credential refresh
# Generated by awsm wrapper command

function aws {
    # Check if credentials are valid by calling aws sts get-caller-identity
    $null = aws sts get-caller-identity 2>$null
    if ($LASTEXITCODE -ne 0) {
        Write-Host "AWS credentials expired or invalid. Refreshing..." -ForegroundColor Yellow
        
        # Attempt to refresh credentials using awsm
        awsm refresh
        if ($LASTEXITCODE -ne 0) {
            Write-Host "Failed to refresh AWS credentials. Please check your awsm configuration." -ForegroundColor Red
            return
        }
        
        Write-Host "Credentials refreshed successfully." -ForegroundColor Green
    }
    
    # Execute the original AWS CLI command with all arguments
    & (Get-Command aws -CommandType Application) @args
}
`
}

// GetInstallPath returns the path where the PowerShell wrapper function should be installed
// For PowerShell, the function is installed directly in the profile file, not a separate file
func (p *PowerShellWrapper) GetInstallPath() (string, error) {
	return GetShellInstallPath(p.shell)
}

// GetConfigFile returns the path to the PowerShell profile file
func (p *PowerShellWrapper) GetConfigFile() (string, error) {
	paths, err := GetShellConfigPaths(p.shell)
	if err != nil {
		return "", err
	}

	// Check for existing config file
	if existing := FindExistingConfigFile(paths); existing != "" {
		return existing, nil
	}

	// Return default path if none exist
	return GetDefaultConfigFile(p.shell)
}

// Install installs the PowerShell wrapper function by appending it to the PowerShell profile
func (p *PowerShellWrapper) Install(functionContent string) error {
	configFile, err := p.GetConfigFile()
	if err != nil {
		return NewWrapperError(string(p.shell), "install", err, "failed to get config file")
	}

	// Check if already installed
	installed, err := p.IsInstalled()
	if err != nil {
		return NewWrapperError(string(p.shell), "install", err, "failed to check installation status")
	}
	if installed {
		return NewWrapperError(string(p.shell), "install", ErrAlreadyInstalled, "wrapper function already exists")
	}

	// Validate config file accessibility
	if err := p.validateConfigFileAccess(configFile); err != nil {
		return err // Already wrapped with proper error context
	}

	// Backup existing config file if it exists
	if FileExists(configFile) {
		if err := BackupFile(configFile); err != nil {
			return NewWrapperError(string(p.shell), "install", ErrBackupFailed,
				fmt.Sprintf("failed to backup PowerShell profile: %s", configFile))
		}
	}

	// Append the wrapper function to the config file
	if err := p.appendToConfigFileWithValidation(configFile, functionContent); err != nil {
		return err // Already wrapped with proper error context
	}

	return nil
}

// validateConfigFileAccess validates that the config file can be created or modified
func (p *PowerShellWrapper) validateConfigFileAccess(configFile string) error {
	// Ensure the config directory exists
	configDir := filepath.Dir(configFile)
	if err := EnsureDir(configDir); err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(p.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied creating profile directory: %s", configDir))
		}
		return NewWrapperError(string(p.shell), "install", err,
			fmt.Sprintf("failed to create profile directory: %s", configDir))
	}

	// Create config file if it doesn't exist
	if !FileExists(configFile) {
		if file, err := os.Create(configFile); err != nil {
			if os.IsPermission(err) {
				return NewWrapperError(string(p.shell), "install", ErrPermissionDenied,
					fmt.Sprintf("permission denied creating PowerShell profile: %s", configFile))
			}
			return NewWrapperError(string(p.shell), "install", err,
				fmt.Sprintf("failed to create PowerShell profile: %s", configFile))
		} else {
			file.Close()
		}
	} else {
		// Test if existing file is writable
		if file, err := os.OpenFile(configFile, os.O_WRONLY|os.O_APPEND, 0644); err != nil {
			if os.IsPermission(err) {
				return NewWrapperError(string(p.shell), "install", ErrConfigFileNotWritable,
					fmt.Sprintf("PowerShell profile is not writable: %s", configFile))
			}
			return NewWrapperError(string(p.shell), "install", err,
				fmt.Sprintf("failed to open PowerShell profile for writing: %s", configFile))
		} else {
			file.Close()
		}
	}

	return nil
}

// appendToConfigFileWithValidation appends the wrapper function with enhanced error handling
func (p *PowerShellWrapper) appendToConfigFileWithValidation(configFile, functionContent string) error {
	// Add a comment header and the function content
	content := fmt.Sprintf("\r\n# Added by awsm wrapper command\r\n%s", functionContent)

	file, err := os.OpenFile(configFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(p.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied opening PowerShell profile: %s", configFile))
		}
		return NewWrapperError(string(p.shell), "install", err,
			fmt.Sprintf("failed to open PowerShell profile: %s", configFile))
	}
	defer file.Close()

	if _, err := file.WriteString(content); err != nil {
		return NewWrapperError(string(p.shell), "install", err,
			fmt.Sprintf("failed to write to PowerShell profile: %s", configFile))
	}

	return nil
}

// Uninstall removes the PowerShell wrapper function from the PowerShell profile
func (p *PowerShellWrapper) Uninstall() error {
	configFile, err := p.GetConfigFile()
	if err != nil {
		return NewWrapperError(string(p.shell), "uninstall", err, "failed to get config file")
	}

	// Check if installed
	installed, err := p.IsInstalled()
	if err != nil {
		return NewWrapperError(string(p.shell), "uninstall", err, "failed to check installation status")
	}
	if !installed {
		return NewWrapperError(string(p.shell), "uninstall", ErrNotInstalled, "wrapper function not found")
	}

	// Backup existing config file
	if err := BackupFile(configFile); err != nil {
		return NewWrapperError(string(p.shell), "uninstall", err, "failed to backup config file")
	}

	// Remove the wrapper function from the config file
	if err := p.removeFromConfigFile(configFile); err != nil {
		return NewWrapperError(string(p.shell), "uninstall", err, "failed to remove function from config file")
	}

	return nil
}

// IsInstalled checks if the PowerShell wrapper function is currently installed
func (p *PowerShellWrapper) IsInstalled() (bool, error) {
	configFile, err := p.GetConfigFile()
	if err != nil {
		return false, NewWrapperError(string(p.shell), "status", err, "failed to get config file")
	}

	if !FileExists(configFile) {
		return false, nil
	}

	return p.functionExistsInFile(configFile), nil
}

// appendToConfigFile appends the wrapper function to the PowerShell profile file
func (p *PowerShellWrapper) appendToConfigFile(configFile, functionContent string) error {
	// Add a comment header and the function content
	content := fmt.Sprintf("\r\n# Added by awsm wrapper command\r\n%s", functionContent)

	file, err := os.OpenFile(configFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		return fmt.Errorf("failed to open config file: %w", err)
	}
	defer file.Close()

	if _, err := file.WriteString(content); err != nil {
		return fmt.Errorf("failed to write to config file: %w", err)
	}

	return nil
}

// removeFromConfigFile removes the wrapper function from the PowerShell profile file
func (p *PowerShellWrapper) removeFromConfigFile(configFile string) error {
	// Read the entire file
	content, err := os.ReadFile(configFile)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	lines := strings.Split(string(content), "\n")
	var newLines []string
	inWrapperSection := false
	inWrapperFunction := false
	braceCount := 0

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)

		// Check if we're entering the wrapper section
		if strings.Contains(line, "Added by awsm wrapper command") {
			inWrapperSection = true
			continue // Skip the comment line
		}

		// Check if we're entering the aws function
		if inWrapperSection && (strings.HasPrefix(trimmedLine, "function aws") || strings.HasPrefix(trimmedLine, "function aws ")) {
			inWrapperFunction = true
			braceCount = 0
			continue // Skip the function declaration
		}

		// Count braces to track function scope in PowerShell
		if inWrapperFunction {
			braceCount += strings.Count(line, "{")
			braceCount -= strings.Count(line, "}")

			// If we've closed all braces, we're done with the function
			if braceCount <= 0 && strings.Contains(line, "}") {
				inWrapperFunction = false
				inWrapperSection = false
				continue // Skip the closing brace line
			}

			// Skip lines that are part of the wrapper function
			continue
		}

		// Keep all other lines
		newLines = append(newLines, line)
	}

	// Write the modified content back to the file
	newContent := strings.Join(newLines, "\n")
	if err := os.WriteFile(configFile, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("failed to write modified config file: %w", err)
	}

	return nil
}

// functionExistsInFile checks if the aws wrapper function exists in the given file
func (p *PowerShellWrapper) functionExistsInFile(configFile string) bool {
	file, err := os.Open(configFile)
	if err != nil {
		return false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	foundComment := false

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Look for the awsm wrapper comment
		if strings.Contains(line, "Added by awsm wrapper command") {
			foundComment = true
			continue
		}

		// Look for the aws function declaration after finding the comment
		if foundComment && (strings.HasPrefix(line, "function aws") || strings.HasPrefix(line, "function aws ")) {
			return true
		}

		// Reset if we find a non-comment, non-aws function line that indicates we've moved past our section
		if foundComment && !strings.HasPrefix(line, "#") && line != "" && !strings.HasPrefix(line, "function aws") {
			// If we find a non-comment line that's not the aws function, keep looking
			// This allows for multiple comment lines between the marker and the function
			continue
		}
	}

	return false
}
