package wrapper

import (
	"fmt"
	"os"
	"path/filepath"
)

// FishWrapper implements WrapperGenerator for Fish shell
type FishWrapper struct {
	shell SupportedShell
}

// GenerateFunction returns the Fish-compatible wrapper function content
func (f *FishWrapper) GenerateFunction() string {
	core := NewWrapperCore()
	function, err := core.GenerateShellWrapperFunction(f.shell)
	if err != nil {
		// Fallback to basic implementation if core generation fails
		return f.generateFallbackFunction()
	}
	return function
}

// generateFallbackFunction provides a fallback implementation
func (f *FishWrapper) generateFallbackFunction() string {
	return `# AWS CLI wrapper function with automatic credential refresh
# Generated by awsm wrapper command

function aws --description "AWS CLI wrapper with automatic credential refresh"
    # Check if credentials are valid by calling aws sts get-caller-identity
    if not command aws sts get-caller-identity >/dev/null 2>&1
        echo "AWS credentials expired or invalid. Refreshing..." >&2
        
        # Attempt to refresh credentials using awsm
        if not awsm refresh
            echo "Failed to refresh AWS credentials. Please check your awsm configuration." >&2
            return 1
        end
        
        echo "Credentials refreshed successfully." >&2
    end
    
    # Execute the original AWS CLI command with all arguments
    command aws $argv
end
`
}

// GetInstallPath returns the path where the Fish wrapper function should be installed
func (f *FishWrapper) GetInstallPath() (string, error) {
	return GetShellInstallPath(f.shell)
}

// GetConfigFile returns the path to the Fish configuration file
func (f *FishWrapper) GetConfigFile() (string, error) {
	paths, err := GetShellConfigPaths(f.shell)
	if err != nil {
		return "", err
	}

	// Check for existing config file
	if existing := FindExistingConfigFile(paths); existing != "" {
		return existing, nil
	}

	// Return default path if none exist
	return GetDefaultConfigFile(f.shell)
}

// Install installs the Fish wrapper function
func (f *FishWrapper) Install(functionContent string) error {
	// Get installation path for the function file
	installPath, err := f.GetInstallPath()
	if err != nil {
		return NewWrapperError(string(f.shell), "install", err, "failed to get install path")
	}

	// Ensure the functions directory exists with validation
	functionsDir := filepath.Dir(installPath)
	if err := f.ensureFunctionsDirectory(functionsDir); err != nil {
		return err // Already wrapped with proper error context
	}

	// Check if already installed
	if FileExists(installPath) {
		return NewWrapperError(string(f.shell), "install", ErrAlreadyInstalled, "wrapper function already exists")
	}

	// Write the function file with validation
	if err := f.writeWrapperFunction(installPath, functionContent); err != nil {
		return err // Already wrapped with proper error context
	}

	return nil
}

// ensureFunctionsDirectory creates the Fish functions directory with validation
func (f *FishWrapper) ensureFunctionsDirectory(functionsDir string) error {
	if err := EnsureDir(functionsDir); err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(f.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied creating functions directory: %s", functionsDir))
		}
		return NewWrapperError(string(f.shell), "install", err,
			fmt.Sprintf("failed to create functions directory: %s", functionsDir))
	}

	// Test write permissions in the functions directory
	testFile := filepath.Join(functionsDir, ".awsm-write-test")
	if file, err := os.Create(testFile); err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(f.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("functions directory is not writable: %s", functionsDir))
		}
		return NewWrapperError(string(f.shell), "install", ErrDirectoryNotWritable,
			fmt.Sprintf("functions directory is not writable: %s", functionsDir))
	} else {
		file.Close()
		os.Remove(testFile)
	}

	return nil
}

// writeWrapperFunction writes the wrapper function with validation
func (f *FishWrapper) writeWrapperFunction(installPath, functionContent string) error {
	if err := os.WriteFile(installPath, []byte(functionContent), 0644); err != nil {
		if os.IsPermission(err) {
			return NewWrapperError(string(f.shell), "install", ErrPermissionDenied,
				fmt.Sprintf("permission denied writing function file: %s", installPath))
		}
		return NewWrapperError(string(f.shell), "install", err,
			fmt.Sprintf("failed to write function file: %s", installPath))
	}
	return nil
}

// Uninstall removes the Fish wrapper function
func (f *FishWrapper) Uninstall() error {
	installPath, err := f.GetInstallPath()
	if err != nil {
		return NewWrapperError(string(f.shell), "uninstall", err, "failed to get install path")
	}

	// Check if installed
	if !FileExists(installPath) {
		return NewWrapperError(string(f.shell), "uninstall", ErrNotInstalled, "wrapper function not found")
	}

	// Remove the function file
	if err := os.Remove(installPath); err != nil {
		return NewWrapperError(string(f.shell), "uninstall", err, "failed to remove function file")
	}

	return nil
}

// IsInstalled checks if the Fish wrapper function is currently installed
func (f *FishWrapper) IsInstalled() (bool, error) {
	installPath, err := f.GetInstallPath()
	if err != nil {
		return false, NewWrapperError(string(f.shell), "status", err, "failed to get install path")
	}

	return FileExists(installPath), nil
}
